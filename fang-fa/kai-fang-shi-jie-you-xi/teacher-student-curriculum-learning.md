# Teacher-Student Curriculum Learning

## 介绍

> [Teacher-Student Curriculum Learning](https://arxiv.org/pdf/1707.00183.pdf)

我们提出了教师 - 学生课程学习（TSCL），这是一个自学课程学习的框架，学生尝试学习一项复杂的任务，教师自动从给定的一组中选择子任务用于学生的学习。我们描述了一系列教师算法，这些算法依赖于直觉，即学生应该练习更多那些最快进步的任务，即学习曲线的斜率最高的地方。此外，教师算法还通过选择学生表现越来越差的任务来解决遗忘问题。我们证明，TSCL在两个任务中匹配或超越了精心设计的课程的结果:在LSTM增加特殊数字和在《我的世界》导航。使用我们自动生成的课程能够解决一个《我的世界》迷宫，当直接训练解决迷宫时，这个迷宫是不可能完全解决的，而且学习比子任务的均匀采样快一个数量级。

## 方法

![](../../.gitbook/assets/image%20%28121%29.png)

图1说明了师生互动。 在每个时间步，教师选择学生进行练习的任务。 学生训练这些任务并返回分数。老师的目标是让学生用尽可能少的训练步骤完成最后的任务。通常，该任务通过表示一个子任务的分类值来参数化，但是可以想象也可以进行多维或连续的任务参数化。该分数可以是在监督学习中的强化总体奖励，或者是在监督学习中的验证集合准确度。

我们将教师帮助学生学习最终任务的目标正式确定为解决部分可见的马可夫决策过程\(POMDP\)问题。我们提出了两个POMDP公式:\(1\)简单，最适合强化学习；和\(2\)批处理，最适合监督学习。

### Simple POMDP Formulation

![](../../.gitbook/assets/image%20%2868%29.png)

### Batch POMDP Formulation

![](../../.gitbook/assets/image%20%288%29.png)

### Optimization Criteria

对于任何一种POMDP公式，最大化教师一集的总奖励相当于在一集结束时最大化所有任务的分数:

$$
\sum_{t=1}^{T} r_{t}=\sum_{i=1}^{N} x_{T_{i}}^{(i)}
$$

虽然优化标准的明显选择可能是最终任务中的表现，但最初学生可能在最终任务中没有任何成功，这并没有向教师提供任何有意义的反馈信号。 因此，我们选择最大化所有任务中的性能总和。

### Algorithms

通常使用强化学习算法来解决POMDP。 但那些需要很多训练剧集，而我们的目标是在一个教师剧集中训练学生。 因此，我们采用更简单的启发式方法。

基本的直觉是，学生应该更多地练习那些能够取得最大进步的任务（Oudeyer和Kaplan，2007），同时还要练习有被遗忘风险的任务。

![](../../.gitbook/assets/image%20%2848%29.png)

图2展示了课程学习环境中理想的训练进度：

* 起初，老师没有知识，所以他从所有的任务中统一取样
* 当学生开始在任务1上取得进展时，教师会为此任务分配更多的概率
* 当学生掌握任务1时，其学习曲线变平并且教师对该任务的抽样不那么频繁。 此时，学生也开始在任务2上取得进展，因此教师样本更多地来自任务2。
* 这一直持续到学生掌握所有任务。 当所有任务学习曲线在最后变平时，教师返回统一的任务抽样

上图是理想化的，因为在实践中经常会发生一些遗忘，即当大部分可能性被分配给任务2时，任务1的表现可能会变得更差。为了应对这种情况，学生还应该练习所有已学的任务，尤其是那些发生遗忘的任务。为此，我们改为根据学习曲线斜率的绝对值对任务进行采样。如果分数的变化是负的，这一定意味着忘记发生了，这项任务应该被更多地实践。

仅此描述并未规定算法。 我们需要提出一种估算嘈杂任务得分的学习进度的方法，以及平衡探索和开发的方法。 来自非固定多臂赌博机问题算法的吸取灵感（Sutton andBarto，1998）并使它们适应TSCL。

#### Online algorithm

它使用指数加权移动平均线来跟踪来自不同任务的预期回报Q.

$$
Q_{t+1}\left(a_{t}\right)=\alpha r_{t}+(1-\alpha) Q_{t}\left(a_{t}\right)
$$

可以使用玻尔兹曼分布选择下一个任务

$$
p(a)=\frac{e^{Q_{t}(a) / \tau}}{\sum_{i=1}^{N} e^{Q_{t}(i) / \tau}}
$$

#### Naive algorithm

为了更可靠地估计学习进度，一个人应该练习几次。简单算法训练每个任务时间，观察结果分数，并使用线性回归估计学习曲线的斜率。

#### Window algorithm

在显然没有进展的情况下，重复任务固定次数是很昂贵的。Window算法保留了最近K个分数的先进先出缓冲区，以及记录这些分数的时间步长。执行线性回归以估计每个任务的学习曲线的斜率，其中时间步长作为输入变量。

#### Sampling algorithm

以前的算法需要调整超参数以平衡探索。 为了摆脱探索超参数，我们从汤普森采样中汲取灵感。采样算法为每个任务保留最近K个分数的缓冲区。为了选择下一个任务，从每个任务的K-last-rewards缓冲区中采样最近的奖励。 然后，无论选择哪个任务产生最高的采样奖励。 这使得探索成为算法的一个自然组成部分：最近具有高效值的任务会被更频繁地采样。

## 实验

### Minecraft

我们只为Minecraft任务实现了Window算法，因为其他算法依赖于得分变化，这对于并行训练方案来说并不是直接计算的。 作为基线，我们使用统一抽样，仅对最后一项任务进行训练，并使用手动调整的课程。

![](../../.gitbook/assets/image%20%2845%29.png)

![](../../.gitbook/assets/image%20%2833%29.png)

